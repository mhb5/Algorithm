给定一个整型数组arr，代表数值不同的纸牌连成一条线，玩家A和B依次拿走每张纸牌，A先拿，B后拿，且每次只能拿走最左或最右的纸牌，A和B都绝顶聪明，请返回最后获胜者的分数。

int scoreCd(const vector<int>& c) {
  if (c.empty()) {
    return 0;
  }
  return std::max(f(c, 0, c.size()-1), s(c, 0, c.size() - 1));
}
//开始抽牌，自己能拿到的最大分数
int f(const vector<int>& c, int l, int r) {
  if (l == r) {
    return c[l];
  }
  return std::max(c[l]+s(c, l+1, r), c[r]+s(c, l, r-1));
}
//开始抽牌，对家能拿到的最大分数
int s(const vector<int>& c, int l, int r) {
  if (l == r) {
    return 0;
  }
  return std::min(f(c, l+1, r), f(c, l, r-1));
}

寄信问题（每人只能寄一封信，收一封信，且不能寄信给自己，求不同人数的寄信方案）
思路：当A寄信给B时，可以把二人看作一个人（寄一封，收一封），后续就变为n-1寄信问题和n-2（A和B互相寄）寄信问题了.

int letter(int n) {
  if (n <= 2) {
    return n - 1;
  }
  return (n-1) * (letter(n-1) + letter(n-2));
}

N皇后问题。
int NQun(int n) {
  if (n < 1 || n > 32) {
    return 0;
  }
  return NQun_proc(n, 0, 0, 0, 0);
}

int NQun_proc(int n, int row, int l, int m, int r) {
  if (row == n) {
    return 1;
  }
  int ret = 0;
  int limit = (l | m | r);
  for (int i = 0; i < n; ++i) {
    if (getBit(limit, i) == 0) {
      int newl = (l | (1 << i)) << 1;
      int newr = (r | (1 << i)) >> 1;
      ret += NQun_proc(n, row+1, newl, setBit(m, i), newr);
    }
  }
  return ret;
}
//最优解
int NQunBst(int n) {
  if (n < 1 || n > 32) {
    return 0;
  }
  int limit = n == 32 ? -1 : ((1 << n) - 1);
  return NQunBst_proc(0, 0, 0, limit);
}

int NQunBst_proc(int l, int m, int r, int limit) {
  if (m == limit) {
    return 1;
  }
  int ret = 0;
  int pos = limit & (~(l | m | r));
  while (pos != 0) {
    auto mostRight = pos & (~pos + 1);
    pos -= mostRight;
    ret += NQunBst_proc((l|mostRight) << 1, m|mostRight, (r|mostRight)>>1, limit);
  }
  return ret;
}

  
